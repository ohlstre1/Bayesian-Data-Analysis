---
title: "BDA_project"
output: pdf_document
Authors: "Edvard OhlstrÃ¶m", "Adam Harmat", "Yeralkhan Slam"
date: "2023-11-06"
---

```{r setup, include=FALSE}
if(!require(medicaldata)){
  install.packages("medicaldata")
}

library(medicaldata)
library(aaltobda)
library(bayesplot)
library(cmdstanr)
library(dplyr)
library(ggplot2)
library(ggdist)
library(posterior)
library(dplyr)
library(reshape2)
library(rstan)
library(cmdstanr)
library(aaltobda)
library(bayesplot)
library(cmdstanr)
library(dplyr)
library(ggdist) # for stat_dotsinterval
library(posterior)
```

## R Markdown

Dataset description -  https://htmlpreview.github.io/?https://github.com/higgi13425/medicaldata/blob/master/man/description_docs/strep_tb_desc.html 




ROUGH toughts

Investigate the drug's efficacy based on different patient baselines, particularly focusing on whether it is more effective for individuals with severe illness compared to those less sick.

you have x y z... features => will the drug work?

find function that gives the prediction based on the patients base conditions

1. logistic regression | input(x|theta, y|theta, z|theta) ->  probablility  {0,1} per patient | model assumption the features are not correlated

  Case 1 - no separation (joint model)
  Case 2 - group by baseline condition (seperate model)
  Case 3 - Do not group but find the common (hierarichal model)

logistic hierarichal | input(x|theta1, y|theta2, z|theta3 ) -> {0,1} per patient | model assumption the feature correlated



TEMP Beta1 prior mean = (y2-y-1)  
TEMP Beta1 prior SD = (diff(extreme value,TEMP prior mean )  - TEMP prior mean ) / 3 = (1-0.5) /3 = 0,1666666667 # probably not good

ESR prior mean = 52-15.5
ESR prior sd = 

```{r}
# data preperation
data("strep_tb")
strep_tb <- na.omit(strep_tb)
summary(strep_tb)
data <- read.csv(file = "strep_tb_scaled.csv", header = TRUE)
data$X <- NULL
data$n = 1

data_medicin = data[data$arm == 1,]
data_control = data[data$arm == 0,]

```

````{r}
#priors

beta_1_mean = 1/(106-93) # tempetrue in farenhieth
beta_1_sd = 20
beta_2_mean = 1/(50-5) # ESR mm/hr
beta_2_sd = 20 
````


````{r}
## creating data_list

matrix_control <- cbind(data_control$baseline_temp, data_control$baseline_esr)

data_list_control <- list(
  N = length(data_control$baseline_temp),
  X = matrix_control,
  y = data_control$improved,
  beta1_prior_mean =  beta_1_mean,
  beta2_prior_mean = beta_1_sd,
  beta1_prior_sd = beta_2_mean,
  beta2_prior_sd= beta_2_sd
  )



matrix_medicin <- cbind(data_medicin$baseline_temp, data_medicin$baseline_esr)

data_list_medicin <- list(
  N = length(data_medicin$baseline_temp),
  X = matrix_medicin,
  y = data_medicin$improved,
  beta1_prior_mean =  beta_1_mean,
  beta2_prior_mean = beta_1_sd,
  beta1_prior_sd = beta_2_mean,
  beta2_prior_sd= beta_2_sd
  )

```

```{r}
## compiling
model_linear<- cmdstan_model(stan_file = "linear_logistic.stan")
model_non_linear<- cmdstan_model(stan_file = "non_linear_logistic.stan")

```
## Linear model, dataset control
```{r}

# Sampling from the posterior distribution happens here:
fit_linear_control <- model_linear$sample(data = data_list_control,
                                      refresh=0,
                                      max_treedepth = 20,
                                      iter_sampling = 4000,
                                      show_messages=FALSE,
                                      show_exceptions=FALSE)
print(fit_linear_control)

(fit_linear_control$summary()[['mean']])


```
## Linear model, dataset medicin
```{r}

# Sampling from the posterior distribution happens here:
fit_linear_medicin <- model_linear$sample(data = data_list_medicin, refresh=0,
                                      iter_sampling = 4000,
                                      max_treedepth = 20,
                                      show_messages=FALSE,
                                      show_exceptions=FALSE)
print(fit_linear_medicin )

```
## Non-Linear model, dataset control
```{r}

# Sampling from the posterior distribution happens here:
fit_nonlinear_control <- model_non_linear$sample(data = data_list_control, refresh=0,
                                      max_treedepth = 20,
                                      show_messages=FALSE,
                                      show_exceptions=FALSE)
print(fit_nonlinear_control )
fit_nonlinear_control.
```


## Non-Linear model, dataset medicin
```{r}

# Sampling from the posterior distribution happens here:
fit_nonlinear_medicin <- model_non_linear$sample(data = data_list_medicin, refresh=0,
                                      max_treedepth = 20,
                                      show_messages=FALSE,
                                      show_exceptions=FALSE)
print(fit_nonlinear_medicin )

```

## Diagnosis
```{r}
print(fit_linear_medicin$cmdstan_diagnose())
print(fit_linear_control$cmdstan_diagnose())

print(fit_nonlinear_medicin$cmdstan_diagnose())
print(fit_nonlinear_control$cmdstan_diagnose())
```

```{r}



print(fit_nonlinear_medicin$summary()[,"mean"])
#generated_values <- extract(fit)
# two colums X1 is probs_mean
accuracy_score <- function(data) {
  binary_predictions <- ifelse(data[, 1] > 0.5, 1, 0)
  correct_predictions <- binary_predictions == data[, 2]
  return(sum(correct_predictions) / nrow(data))
}
fit_to_accuracy <- function(fit, data_labels){
  probs <- fit$summary()[['mean']]
  probs <- probs[5:length(probs)]

  output <- cbind(probs, data_labels)
  return(accuracy_score(output))
}

print(fit_to_accuracy(fit=fit_linear_medicin,  data_medicin$improved ))
print(fit_to_accuracy(fit=fit_linear_control,  data_control$improved ))
print(fit_to_accuracy(fit=fit_nonlinear_medicin,  data_medicin$improved ))
print(fit_to_accuracy(fit=fit_nonlinear_control,  data_control$improved ))




```
```{r}

m <- fit_linear_medicin$summary()[['mean']]
q95 <- fit_linear_medicin$summary()[['q95']]
q5 <- fit_linear_medicin$summary()[['q5']]
cbind(q5, m, q95)

````

Assume all hospitals have same distribution vs individual (non hierarchical and hierarchical)
Test risk group 1, risk group 2...  (variable selection with many models)

