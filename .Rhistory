library(rstan)
library(cmdstanr)
library(aaltobda)
library(bayesplot)
library(cmdstanr)
library(dplyr)
library(ggdist) # for stat_dotsinterval
library(posterior)
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
# Sampling from the posterior distribution happens here:
fit_pooled <- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
fit$diagnose()
rstan:::rstudio_stanc("logistic_model.stan")
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
stanc --auto-format "logistic_model.stan"
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
stanc --auto-format "logistic_model.stan"
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
# Sampling from the posterior distribution happens here:
fit_pooled <- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
# Sampling from the posterior distribution happens here:
fit_pooled <- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
print(fit_pooled)
rstan:::rstudio_stanc("logistic_model.stan")
fit_pooled$cmdstan_diagnose()
generated_values <- extract(fit)
View(generated_values)
generated_values$y_pred_prob
y_pred_prob = generated_values$y_pred_prob[]
View(y_pred_prob)
View(generated_values)
generated_values[["y_pred_prob"]]
y_pred_prob = generated_values$y_pred_prob[4000,]
rstan:::rstudio_stanc("logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
# Sampling from the posterior distribution happens here:
fit<- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
# Sampling from the posterior distribution happens here:
fit<- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
print(fit_pooled)
generated_values <- extract(fit)
print(fit)
generated_values <- extract(fit)
generated_values <- extract(fit)
View(data)
data("strep_tb")
data("strep_tb")
library(medicaldata)
data("strep_tb")
force(strep_tb)
rm(list=ls())
data("strep_tb")
View(strep_tb)
sterp_tb
strep_tb[0:5]
View(strep_tb)
data <- read.csv(file = "strep_tb_scaled.csv", header = TRUE)
View(data)
data$X <- NULL
data[0:5]
data
rstan:::rstudio_stanc("logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
data_list <- list(
N = length(data$baseline_temp),
X <- as.matrix(df[, c(data$baseline_temp, data$baseline_esr,)]),
y = data$improved
)
data_list <- list(
N = length(data$baseline_temp),
X <- as.matrix(data$baseline_temp, data$baseline_esr),
y = data$improved
)
#fit <- stan(file = "logistic_model.stan", data = data_list, chains = 4, iter = 2000)
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
rstan:::rstudio_stanc("logistic_model.stan")
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
# Sampling from the posterior distribution happens here:
fit<- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
matrix <- as.matrix(data$baseline_temp, data$baseline_esr)
View(matrix)
View(matrix)
data$baseline_esr
data$baseline_temp
matrix <- as.matrix(c(data$baseline_temp, data$baseline_esr))
matrix <- data
View(matrix)
matrix <- cbind(data$baseline_temp, data$baseline_esr)
data_list <- list(
N = length(data$baseline_temp),
X <- as.matrix(data$baseline_temp, data$baseline_esr),
y = data$improved
)
#fit <- stan(file = "logistic_model.stan", data = data_list, chains = 4, iter = 2000)
# Sampling from the posterior distribution happens here:
fit<- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
matrix <- cbind(data$baseline_temp, data$baseline_esr)
data_list <- list(
N = length(data$baseline_temp),
X <- matrix,
y = data$improved
)
#fit <- stan(file = "logistic_model.stan", data = data_list, chains = 4, iter = 2000)
matrix <- cbind(data$baseline_temp, data$baseline_esr)
data_list <- list(
N = length(data$baseline_temp),
X <- matrix,
y = data$improved
)
#fit <- stan(file = "logistic_model.stan", data = data_list, chains = 4, iter = 2000)
model_pooled<- cmdstan_model(stan_file = "logistic_model.stan")
# Sampling from the posterior distribution happens here:
fit<- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
View(matrix)
shape(matrix)
matrix
# Sampling from the posterior distribution happens here:
fit<- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
str(data_list)
data_list <- list(
N = length(data$baseline_temp),
X = matrix,
y = data$improved
)
# Sampling from the posterior distribution happens here:
fit<- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
# Sampling from the posterior distribution happens here:
fit<- model_pooled$sample(data = data_list, refresh=0,
show_messages=FALSE,
show_exceptions=FALSE)
print(fit)
fit$cmdstan_diagnose()
if(!require(medicaldata)){
install.packages("medicaldata")
}
library(medicaldata)
library(aaltobda)
library(bayesplot)
library(cmdstanr)
library(dplyr)
library(ggplot2)
library(ggdist)
library(posterior)
library(dplyr)
library(reshape2)
library(rstan)
library(cmdstanr)
library(aaltobda)
library(bayesplot)
library(cmdstanr)
library(dplyr)
library(ggdist) # for stat_dotsinterval
library(posterior)
fit$draws()
if(!require(medicaldata)){
install.packages("medicaldata")
}
library(medicaldata)
library(aaltobda)
library(bayesplot)
library(cmdstanr)
library(dplyr)
library(ggplot2)
library(ggdist)
library(posterior)
library(dplyr)
library(reshape2)
library(rstan)
library(cmdstanr)
library(aaltobda)
library(bayesplot)
library(cmdstanr)
library(dplyr)
library(ggdist) # for stat_dotsinterval
library(posterior)
# data preperation
data("strep_tb")
strep_tb <- na.omit(strep_tb)
summary(strep_tb)
data <- read.csv(file = "strep_tb_scaled.csv", header = TRUE)
data$X <- NULL
data$n = 1
data_medicin = data[data$arm == 1,]
data_control = data[data$arm == 0,]
#priors
beta_1_mean = 1/(106-93) # tempetrue in farenhieth
beta_1_sd = 20
beta_2_mean = 1/(50-5) # ESR mm/hr
beta_2_sd = 20
## creating data_list
matrix_control <- cbind(data_control$baseline_temp, data_control$baseline_esr)
data_list_control <- list(
N = length(data_control$baseline_temp),
X = matrix_control,
y = data_control$improved,
beta1_prior_mean =  beta_1_mean,
beta2_prior_mean = beta_1_sd,
beta1_prior_sd = beta_2_mean,
beta2_prior_sd= beta_2_sd
)
matrix_medicin <- cbind(data_medicin$baseline_temp, data_medicin$baseline_esr)
data_list_medicin <- list(
N = length(data_medicin$baseline_temp),
X = matrix_medicin,
y = data_medicin$improved,
beta1_prior_mean =  beta_1_mean,
beta2_prior_mean = beta_1_sd,
beta1_prior_sd = beta_2_mean,
beta2_prior_sd= beta_2_sd
)
## compiling
model_linear<- cmdstan_model(stan_file = "linear_logistic.stan")
model_non_linear<- cmdstan_model(stan_file = "non_linear_logistic.stan")
# Sampling from the posterior distribution happens here:
fit_linear_control <- model_linear$sample(data = data_list_control,
refresh=0,
max_treedepth = 20,
iter_sampling = 4000,
show_messages=FALSE,
show_exceptions=FALSE)
print(fit_linear_control)
# Sampling from the posterior distribution happens here:
fit_linear_medicin <- model_linear$sample(data = data_list_medicin, refresh=0,
iter_sampling = 4000,
max_treedepth = 20,
show_messages=FALSE,
show_exceptions=FALSE)
print(fit_linear_medicin )
# Sampling from the posterior distribution happens here:
fit_nonlinear_control <- model_non_linear$sample(data = data_list_control, refresh=0,
max_treedepth = 20,
show_messages=FALSE,
show_exceptions=FALSE)
print(fit_nonlinear_control )
# Sampling from the posterior distribution happens here:
fit_nonlinear_medicin <- model_non_linear$sample(data = data_list_medicin, refresh=0,
max_treedepth = 20,
show_messages=FALSE,
show_exceptions=FALSE)
print(fit_nonlinear_medicin )
print(fit_linear_medicin$cmdstan_diagnose())
print(fit_linear_control$cmdstan_diagnose())
print(fit_nonlinear_medicin$cmdstan_diagnose())
print(fit_nonlinear_control$cmdstan_diagnose())
print(fit_nonlinear_medicin$summary()[,"mean"])
#generated_values <- extract(fit)
# two colums X1 is probs_mean
accuracy_score <- function(data) {
binary_predictions <- ifelse(data[, 1] > 0.5, 1, 0)
correct_predictions <- binary_predictions == data[, 2]
return(sum(correct_predictions) / nrow(data))
}
fit_to_accuracy <- function(fit, data_labels){
probs <- fit$summary()[['mean']]
probs <- probs[5:length(probs)]
output <- cbind(probs, data_labels)
return(accuracy_score(output))
}
print(fit_to_accuracy(fit=fit_linear_medicin,  data_medicin$improved ))
print(fit_to_accuracy(fit=fit_linear_control,  data_control$improved ))
print(fit_to_accuracy(fit=fit_nonlinear_medicin,  data_medicin$improved ))
print(fit_to_accuracy(fit=fit_nonlinear_control,  data_control$improved ))
unique_parameter_distribution <- function (posterior){
means <- fit$draws()
}
unique_arg_values <- function(fit, if_linear, is_medicin) {
means <- fit$summary()[['mean']]
unique_means <- unique(means)
indices_of_unique_means <- match(unique_means, means)
if(if_linear){
if(is_medicin){
return(indices_of_unique_means[5:length(indices_of_unique_means)])
}else{
return(indices_of_unique_means[11:length(indices_of_unique_means)-3])
}
}else{
if(is_medicin){
return(indices_of_unique_means[6:length(indices_of_unique_means)])
}else{
return(indices_of_unique_means[11:length(indices_of_unique_means)-3])
}
}
}
plot_mcmc <- function(fit, title_name , if_linear, is_medicin) {
unique_indexes <- unique_arg_values(fit , if_linear, is_medicin)
posterior_samples <- fit$draws()
posterior_len <- length(posterior_samples[,1,1])
y_prob_mean_vector <-posterior_samples[(posterior_len-100):posterior_len, 4, unique_indexes]
plot <- bayesplot::mcmc_areas(y_prob_mean_vector, prob = 0.5, prob_outer = 0.90)
plot_with_title <- plot + ggtitle(title_name)
print(plot_with_title)
}
plot_mcmc(fit_linear_control, "Model - Linear; Data - Control", 1, 0)
plot_mcmc(fit_linear_medicin, "Model - Linear; Data - Streptomycin", 1, 1)
plot_mcmc(fit_nonlinear_medicin, "Model - Non-Linear; Data - Streptomycin", 0, 1)
plot_mcmc(fit_nonlinear_control, "Model - Non-Linear; Data - Control", 0, 0)
fit$draws()
fit$draws()
```
dim(fit$draws())
fit$draws()[,1,1]
fit$draws()[,1,2:4]
mean_values <- apply(data_extracted, 2, mean)
data_extracted <- fit$draws()[, , 2:4]
mean_values <- apply(data_extracted, 2, mean)
mean_values
mean_values <- apply(data_extracted, 1, mean)
data_extracted <- fit$draws()[, , 2:4]
mean_values <- apply(data_extracted, 1, mean)
mean_values
dim(mean_values)
mean_values
data_extracted <- fit$draws()[, , 2]
data_extracted
fit$draws()[, , 3]
apply(data_extracted, 1, mean)
unique_parameter_distribution <- function(fit1, fit2, fit3, fit4) {
# Function to extract and compute means
get_means <- function(fit, parameter_index) {
draws <- fit$draws()[, , parameter_index]
apply(draws, 1, mean)
}
# Compute means for each parameter across all fits
fits <- list(fit1, fit2, fit3, fit4)
alpha_means <- lapply(fits, function(fit) get_means(fit, 4))
beta1_means <- lapply(fits, function(fit) get_means(fit, 2))
beta2_means <- lapply(fits, function(fit) get_means(fit, 3))
# Generate plots for each parameter
plot_alpha <- lapply(alpha_means, function(means) bayesplot::mcmc_areas(means, prob = 0.5, prob_outer = 0.90))
plot_beta1 <- lapply(beta1_means, function(means) bayesplot::mcmc_areas(means, prob = 0.5, prob_outer = 0.90))
plot_beta2 <- lapply(beta2_means, function(means) bayesplot::mcmc_areas(means, prob = 0.5, prob_outer = 0.90))
# Arrange plots into subplots
gridExtra::grid.arrange(grobs = c(plot_alpha, plot_beta1, plot_beta2), ncol = 3)
}
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
unique_parameter_distribution <- function(fit1, fit2, fit3, fit4) {
# Function to extract draws for a given parameter index
get_draws <- function(fit, parameter_index) {
fit$draws()[, , parameter_index]
}
# Extract draws for each parameter across all fits
fits <- list(fit1, fit2, fit3, fit4)
alpha_draws <- lapply(fits, function(fit) get_draws(fit, 4))
beta1_draws <- lapply(fits, function(fit) get_draws(fit, 2))
beta2_draws <- lapply(fits, function(fit) get_draws(fit, 3))
# Generate plots for each parameter
plot_alpha <- lapply(alpha_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta1 <- lapply(beta1_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta2 <- lapply(beta2_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
# Arrange plots into subplots
gridExtra::grid.arrange(grobs = c(plot_alpha, plot_beta1, plot_beta2), ncol = 3)
}
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
unique_parameter_distribution <- function(fit1, fit2, fit3, fit4) {
# Function to extract draws for a given parameter index
get_draws <- function(fit, parameter_index) {
fit$draws()[, , parameter_index]
}
# Extract draws for each parameter across all fits
fits <- list(fit1, fit2, fit3, fit4)
alpha_draws <- lapply(fits, function(fit) get_draws(fit, 4))
beta1_draws <- lapply(fits, function(fit) get_draws(fit, 2))
beta2_draws <- lapply(fits, function(fit) get_draws(fit, 3))
# Generate plots for each parameter
plot_alpha <- lapply(alpha_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta1 <- lapply(beta1_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta2 <- lapply(beta2_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
# Arrange plots into subplots
gridExtra::grid.arrange(grobs = c(plot_alpha, plot_beta1, plot_beta2), ncol = 4)
}
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
print(dim(beta1_draws)
# Generate plots for each parameter
plot_alpha <- lapply(alpha_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
unique_parameter_distribution <- function(fit1, fit2, fit3, fit4) {
# Function to extract draws for a given parameter index
get_draws <- function(fit, parameter_index) {
fit$draws()[, , parameter_index]
}
# Extract draws for each parameter across all fits
fits <- list(fit1, fit2, fit3, fit4)
alpha_draws <- lapply(fits, function(fit) get_draws(fit, 4))
beta1_draws <- lapply(fits, function(fit) get_draws(fit, 2))
beta2_draws <- lapply(fits, function(fit) get_draws(fit, 3))
print(dim(beta1_draws))
# Generate plots for each parameter
plot_alpha <- lapply(alpha_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta1 <- lapply(beta1_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta2 <- lapply(beta2_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
# Arrange plots into subplots
gridExtra::grid.arrange(grobs = c(plot_alpha, plot_beta1, plot_beta2), ncol = 4)
}
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
dim(fit$draws())
x <- dim(fit$draws())[1]
dim(fit$draws())[1]
fit$draws()[length_draws-100:length_draws , , parameter_index]
unique_parameter_distribution <- function(fit1, fit2, fit3, fit4) {
# Function to extract draws for a given parameter index
get_draws <- function(fit, parameter_index) {
length_draws = dim(fit$draws())[1]
fit$draws()[length_draws-100:length_draws , , parameter_index]
}
# Extract draws for each parameter across all fits
fits <- list(fit1, fit2, fit3, fit4)
alpha_draws <- lapply(fits, function(fit) get_draws(fit, 4))
beta1_draws <- lapply(fits, function(fit) get_draws(fit, 2))
beta2_draws <- lapply(fits, function(fit) get_draws(fit, 3))
print(dim(beta1_draws))
# Generate plots for each parameter
plot_alpha <- lapply(alpha_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta1 <- lapply(beta1_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta2 <- lapply(beta2_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
# Arrange plots into subplots
gridExtra::grid.arrange(grobs = c(plot_alpha, plot_beta1, plot_beta2), ncol = 4)
}
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
fit$draws()[length_draws-300:length_draws , , parameter_index]
unique_parameter_distribution <- function(fit1, fit2, fit3, fit4) {
# Function to extract draws for a given parameter index
get_draws <- function(fit, parameter_index) {
length_draws = dim(fit$draws())[1]
fit$draws()[length_draws-300:length_draws , , parameter_index]
}
# Extract draws for each parameter across all fits
fits <- list(fit1, fit2, fit3, fit4)
alpha_draws <- lapply(fits, function(fit) get_draws(fit, 4))
beta1_draws <- lapply(fits, function(fit) get_draws(fit, 2))
beta2_draws <- lapply(fits, function(fit) get_draws(fit, 3))
print(dim(beta1_draws))
# Generate plots for each parameter
plot_alpha <- lapply(alpha_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta1 <- lapply(beta1_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta2 <- lapply(beta2_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
# Arrange plots into subplots
gridExtra::grid.arrange(grobs = c(plot_alpha, plot_beta1, plot_beta2), ncol = 4)
}
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
# Generate plots for each parameter
plot_beta1 <- lapply(beta1_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
unique_parameter_distribution <- function(fit1, fit2, fit3, fit4) {
# Function to extract draws for a given parameter index
get_draws <- function(fit, parameter_index) {
length_draws = dim(fit$draws())[1]
fit$draws()[length_draws-300:length_draws , , parameter_index]
}
# Extract draws for each parameter across all fits
fits <- list(fit1, fit2, fit3, fit4)
alpha_draws <- lapply(fits, function(fit) get_draws(fit, 4))
beta1_draws <- lapply(fits, function(fit) get_draws(fit, 2))
beta2_draws <- lapply(fits, function(fit) get_draws(fit, 3))
print(dim(beta1_draws))
# Generate plots for each parameter
plot_beta1 <- lapply(beta1_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta2 <- lapply(beta2_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
# Arrange plots into subplots
gridExtra::grid.arrange(grobs = c(plot_alpha, plot_beta1, plot_beta2), ncol = 4)
}
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
unique_parameter_distribution <- function(fit1, fit2, fit3, fit4) {
# Function to extract draws for a given parameter index
get_draws <- function(fit, parameter_index) {
length_draws = dim(fit$draws())[1]
fit$draws()[length_draws-300:length_draws , , parameter_index]
}
# Extract draws for each parameter across all fits
fits <- list(fit1, fit2, fit3, fit4)
alpha_draws <- lapply(fits, function(fit) get_draws(fit, 4))
beta1_draws <- lapply(fits, function(fit) get_draws(fit, 2))
beta2_draws <- lapply(fits, function(fit) get_draws(fit, 3))
print(dim(beta1_draws))
# Generate plots for each parameter
plot_alpha <- lapply(alpha_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta1 <- lapply(beta1_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
plot_beta2 <- lapply(beta2_draws, function(draws) bayesplot::mcmc_areas(draws, prob = 0.5, prob_outer = 0.90))
# Arrange plots into subplots
gridExtra::grid.arrange(grobs = c(plot_alpha, plot_beta1, plot_beta2), ncol = 4)
}
unique_parameter_distribution(fit_linear_control, fit_nonlinear_control, fit_linear_medicin, fit_nonlinear_medicin)
